# CS300-Portfolio
Portfolio work for CS 300
## Reflection

**1. What was the problem you were solving in the projects for this course?**  
The main problem I was solving was how to efficiently store, manage, and retrieve data using different data structures. Each project required implementing and analyzing algorithms that demonstrate sorting, searching, and organization of data, while also considering time and memory efficiency.

**2. How did you approach the problem? Consider why data structures are important to understand.**  
I approached the problems by first breaking them down into smaller steps and then determining which data structure would be the most efficient for the task. Data structures are critical because they directly affect program performance in terms of runtime and memory usage. Choosing the correct structure allowed me to design solutions that were both effective and efficient.

**3. How did you overcome any roadblocks you encountered while going through the activities or project?**  
When I encountered roadblocks, such as unexpected runtime errors or logic issues in my sorting algorithms, I relied on debugging techniques, testing with sample data, and reviewing documentation. I also used incremental development, testing each part of the program step by step, which made it easier to locate and fix issues.

**4. How has your work on this project expanded your approach to designing software and developing programs?**  
This project has helped me expand my approach by reinforcing the importance of analyzing algorithm complexity before implementation. I now place more emphasis on designing solutions with efficiency in mind, rather than just focusing on functionality. It also showed me the value of code readability and reusability when designing larger programs.

**5. How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?**  
Through this project, I have learned to write cleaner, more organized code with consistent formatting and documentation. I focus more on modular design, where functions and classes are separated by responsibility, which makes the code easier to maintain. I also prioritize adaptability by considering how the program could be expanded or reused in different contexts.
